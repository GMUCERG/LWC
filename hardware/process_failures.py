#!/usr/bin/env python3

# Description: Post-process failed_test_vectors.txt generated by LWC_TB in case of verification failures
# Author:      Kamyar Mohajerani (kamyar@ieee.org)

from enum import Enum
from pathlib import Path
import copy
import re
import os
from glob import glob
import argparse
from typing import List
# import json

argparser = argparse.ArgumentParser()
argparser.add_argument(
    '--all-path', default=os.path.curdir, help='find all failed_test_vectors.txt and corresponding pdi.txt, sdi.txt, and do.txt in the subdirectories of this path')
# argparser.add_argument('--failed_test_vectors', help='Path to failed_test_vectors.txt file generated by LWC_TB')
# argparser.add_argument('--kat_dir', help='Path to KAT directory containing pdi.txt, sdi.txt, and do.txt')
argparser.add_argument('--debug', help='Print debug messages')

args = argparser.parse_args()

# failed_test_vectors_txt = Path(args.failed_test_vectors)
# kat_dir = Path(args.kat_dir)

word_nibbles = None


def datawords(d):
    length = word_nibbles
    return ((1 + i//length,d[i:length+i])for i in range(0, len(d), length))

class Opcode(Enum):
    HASH    = 0b1000
    ENC     = 0b0010
    DEC     = 0b0011
    LDKEY   = 0b0100
    ACTKEY  = 0b0111
    # SUCCESS = 0b1110
    # FAILURE = 0b1111

    def to_name(self):
        if self == Opcode.HASH:
            return 'Hashing'
        if self == Opcode.ENC:
            return 'Authenticated Encryption'
        if self == Opcode.DEC:
            return 'Authenticated Decryption'
        return None


class HeaderType(Enum):
    AD         = 0b0001
    PT         = 0b0100
    CT         = 0b0101
    TAG        = 0b1000
    KEY        = 0b1100
    NPUB       = 0b1101
    HASH_MSG   = 0b0111
    HASH_VALUE = 0b1001


    @classmethod
    def decode(cls, header):
        header = header.upper()
        return HeaderType(int(header[0], 16))

class Header():
    def __init__(self, type, segment_len, partial, eoi, eot, last) -> None:
        self.type = type
        self.segment_len = segment_len
        self.partial = partial
        self.eoi = eoi
        self.eot = eot
        self.last = last
    @classmethod
    def decode(cls, header):
        sn = int(header[1],16)
        return Header(HeaderType.decode(header), int(header[4:], 16), sn&8, sn&4, sn&2, sn&1)


def decode_inst(ins: str):
    ins = ins.upper()
    global word_nibbles
    if not word_nibbles:
        word_nibbles = len(ins)
    return Opcode(int(ins[0], 16))


class Segment():
    def __init__(self, line_num, header: Header) -> None:
        self.line_num = line_num
        self.header = header
        self.data = []

    def all_data(self):
        return ''.join(map(lambda dw: dw.word, self.data))[:self.header.segment_len*2]


class DataWord():
    def __init__(self, line_num, word_num, word) -> None:
        self.line_num = line_num
        self.word_num = word_num
        self.word = word

class Instruction():
    def __init__(self, line_num, op) -> None:
        self.line_num = line_num
        self.op = op
        self.hdr_data = []


class StatusType(Enum):
    SUCCESS = 14
    FAILURE = 15
    UNKNOWN = 00

class Status():
    def __init__(self, line_num, stt) -> None:
        self.line_num = line_num
        try:
            self.type = StatusType(int(stt[0], 16))
        except ValueError:
            self.type = StatusType.UNKNOWN


msg_id_comment_re = re.compile(r'\#\#\#\# MsgID=\s*(?P<msgid>\d+),\s*KeyID=\s*(?P<keyid>\d+)')

keyid_of_msgid = {}

def parse_di(file, is_sdi=False):
    di_dict = {}
    current_inst = None
    current_seg = None
    msgid = None
    with open(file) as f:
        for line_num, line in enumerate(f.readlines()):
            line_num += 1
            line = line.strip()
            if args.debug:
                print(f'{file}:{line_num}')
            match = msg_id_comment_re.match(line)
            if match:
                msgid = int(match.group('msgid'))
                keyid = int(match.group('keyid'))
                if is_sdi:
                    msgid = keyid
                else:
                    keyid_of_msgid[msgid] = keyid
                di_dict[msgid] = []
            elif line and not line.startswith('#'):
                t,d = line.split(' = ')
                if t == 'INS':
                    current_inst = Instruction(line_num, decode_inst(d))
                    di_dict[msgid].append(current_inst)
                elif t == 'HDR':
                    current_seg = Segment(line_num, Header.decode(d))
                    current_inst.hdr_data.append(current_seg)
                elif t == 'DAT':
                    for word_num, word in datawords(d):
                        current_seg.data.append(DataWord(line_num, word_num, word))

    return di_dict


def parse_do(file):
    do_dict = {}
    current_sega = None
    msgid = None
    with open(file) as f:
        for line_num, line in enumerate(f.readlines()):
            line_num += 1
            line = line.strip()
            if args.debug:
                print(f'{file}:{line_num}')
            match = msg_id_comment_re.match(line)
            if match:
                msgid = int(match.group('msgid'))
                do_dict[msgid] = []
            elif line and not line.startswith('#'):
                t, d = line.split(' = ')
                if t == 'STT':
                    do_dict[msgid].append(Status(line_num, d))
                elif t == 'HDR':
                    current_sega = Segment(line_num, Header.decode(d))
                    do_dict[msgid].append(current_sega)
                elif t == 'DAT':
                    for word_num, word in datawords(d):
                        current_sega.data.append(DataWord(line_num, word_num, word))

    return do_dict


if args.all_path:
    for failed_test_vectors_txt in glob('**/*/failed_test_vectors.txt', recursive=True):
        print(f'processing {failed_test_vectors_txt}')
        kat_dir = Path(failed_test_vectors_txt).parent

        decoded_pdi = parse_di(kat_dir / 'pdi.txt')
        decoded_sdi = parse_di(kat_dir / 'sdi.txt')
        expected_do = parse_do(kat_dir / 'do.txt')

        recieved_do = {}

        # def dump(fname, data):
        #     with open(fname, 'w') as f:
        #         json.dump(data, f, default=lambda x: x.__dict__ if hasattr(x, '__dict__') else str(x), indent=4)

        # dump('pdi.json', decoded_pdi)
        # dump('sdi.json', decoded_sdi)
        # dump('do.json', expected_do)

        def patch_do_record(do_record: List[Segment], line_num, word_num, orig_word, replace_word):
            for hdr_data in do_record:
                # check header/status itself
                if hdr_data.line_num == line_num and word_num == 1 and isinstance(hdr_data, Status):
                    hdr_data=Status(line_num, replace_word)
                    return
                if hdr_data.line_num == line_num and word_num == 1 and hdr_data.header == orig_word:
                    hdr_data.header = replace_word
                    return
                if isinstance(hdr_data, Segment):
                    for data in hdr_data.data:
                        # print(f'l: {data.line_num} w: {data.word_num} word: {data.word}')
                        if data.line_num == line_num and data.word_num == word_num and data.word == orig_word:
                            # print(f'found!')
                            data.word = replace_word
                            return
            raise Exception(f'record not found: line:{line_num} word:{word_num} orig_word:{orig_word} in {do_record}')


        failed_test_re = re.compile(
            r'Failure #(?P<idx>\d+)\s+MsgID: (?P<msgid>\d+).*Line: (?P<line>\d+) Word: (?P<word>\d+) Expected: (?P<expected>\w+) Received: (?P<received>\w+)\s*')
        with open(failed_test_vectors_txt) as f:
            for line in f.readlines():
                line = line.strip()
                if line:
                    match = failed_test_re.match(line)
                    if not match:
                        raise Exception(f'error parsing {failed_test_vectors_txt}')
                    msgid = int(match.group('msgid'))
                    line_num = int(match.group('line'))
                    word_num = int(match.group('word'))
                    expected = match.group('expected')
                    received = match.group('received')
                    if msgid not in recieved_do:
                        recieved_do[msgid] = copy.deepcopy(expected_do[msgid])
                    # print(f"msgid={msgid}")
                    patch_do_record(recieved_do[msgid], line_num, word_num, expected, received)
                    pdi_record = decoded_pdi.get(msgid)
                    sdi_record = decoded_sdi.get(msgid)

        def shortname(enum):
            return str(enum).split('.')[1]


        if recieved_do:
            with open(kat_dir / 'processed_failures.txt', 'w') as outfile:
                print(f'writing {outfile.name}')
                for idx, (msgid, received) in enumerate(recieved_do.items()):
                    pdi = decoded_pdi[msgid]
                    keyid = keyid_of_msgid[msgid]
                    sdi = decoded_sdi.get(keyid)

                    expected = expected_do[msgid]
                    print(f'------------ Failure #{idx+1}   MsgID = {msgid} ------------', file=outfile)

                    new_key = False
                    for inst in pdi:
                        op_name = inst.op.to_name()
                        if op_name:
                            print(f'Operation: {op_name}', file=outfile)
                        if inst.op == Opcode.ACTKEY:
                            print(f"New Key KeyID={keyid}", file=outfile)
                            new_key = True
                        elif inst.op == Opcode.ENC or inst.op == Opcode.DEC:
                            if not new_key:
                                print(f"Reusing previously loaded key (KeyID={keyid})", file=outfile)
                            for hdr_dat in sdi[0].hdr_data:
                                print(f"{shortname(hdr_dat.header.type)}: {hdr_dat.all_data()}", file=outfile)
                        for hdr_dat in inst.hdr_data:
                            print(f"{shortname(hdr_dat.header.type)}: {hdr_dat.all_data()}", file=outfile)
                    for recv_seg, exp_seg in zip(received, expected):
                        if isinstance(recv_seg, Status):
                            if recv_seg.type != exp_seg.type:
                                print(f"Received status: {recv_seg.type} Expected: {exp_seg.type}", file=outfile)
                        else:
                            # if recv_seg.header != exp_seg.header:
                            #     print(f'Header:')
                            #     print(f'    Expected:{exp_seg.header.type}\n    Received:{recv_seg.header.type}')
                            rd = recv_seg.all_data()
                            ed = exp_seg.all_data()
                            if rd != ed:
                                print(f'{shortname(recv_seg.header.type)}:', file=outfile)
                                print(f'    Expected: {ed}\n    Received: {rd}', file=outfile)
                            else:
                                print(f'{shortname(recv_seg.header.type)}: {rd}', file=outfile)
                    print(file=outfile)
